/*--------------------------------------------------------------------------+
|                                                                          |
| Copyright 2008-2012 Technische Universitaet Muenchen                     |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+--------------------------------------------------------------------------*/

group embedded-cfile;

/* Type definitions from Proto.g
 * TYPE
 *  : 'double' | 'float' | 'int32' | 'int64' | 'uint32' | 'uint64' | 'sint32' | 'sint64'
 *  | 'fixed32' | 'fixed64' | 'sfixed32' | 'sfixed64' | 'bool' | 'string' | 'bytes'
 *  ;
 */

typeMap ::= [
  "double":"double",
  "float":"float",
  "int32":"signed long",
  "int64":"signed long long",
  "uint32":"unsigned long",
  "uint64":"unsigned long long",
  "sint32":"signed long",
  "sint64":"signed long long",
  "fixed32":"unsigned long",
  "fixed64":"unsigned long long",
  "sfixed32":"signed long",
  "sfixed64":"signed long long",
  "bool":"char",
  "string":"char",
  "bytes":"char"]

enumTypeMap ::= ["enum":"enum"]
messageTypeMap ::= ["message":"struct"]
arrayTypes ::= ["string":"true", "bytes":"true"]  
arraySTypes ::= ["string":"true"]
arrayBTypes ::= ["bytes":"true"]
arrayModifiers ::= ["repeated":"true"]

proto(packageDecl, importDecls, declarations, filename, max_repeated_length, max_string_length, max_bytes_length) ::= <<
/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : $filename$.proto
 * Package: $packageDecl$
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/
 
#ifndef _$filename$_H
#define _$filename$_H

#ifdef __cplusplus
  extern "C" {
#endif

$importDecls; separator="\n"$

#define MAX_REPEATED_LEN $max_repeated_length$
#define MAX_STRING_LEN $max_string_length$
#define MAX_BYTES_LEN $max_bytes_length$

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);


$declarations; separator="\n\n"$

#ifdef _cplusplus
  }
#endif

#endif

>>

packageDecl(qualifiedID) ::= <<$qualifiedID$>>

importDecl(name) ::= <<
#include <$name$.h>
>>


enumDecl(name, elements, filename, line) ::= <<
/*******************************************************************
 * Enumeration: $filename$.proto, line $line$
 *******************************************************************/
enum $name$ {
  $elements; separator=",\n"$
};
>>

enumElement(name, value) ::= <<
_$name$ = $value$
>>
 
messageDecl(name, elements, filename, line, maxsize, empty, bigvalues) ::= <<
/*******************************************************************
 * Message: $filename$.proto, line $line$
 *******************************************************************/

/* Maximum size of a serialized $name$-message, useful for buffer allocation. */
#define MAX_$name$_SIZE $maxsize$

$if(empty)$$else$
/* Structure that holds a deserialized $name$-message. */
struct $name$ {
  $elements; separator="\n"$
};
$endif$

/*
 * Serialize a $name$-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int $name$_write_delimited_to($if(empty)$$else$struct $name$ *_$name$, $endif$void *_buffer, int offset);

/*
 * Serialize a $name$-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a $name$-message is embedded in another message.
 */
int $name$_write_with_tag($if(empty)$$else$struct $name$ *_$name$, $endif$void *_buffer, int offset, int tag);

/*
 * Deserialize a $name$-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: $if(empty)$$name$-messages are empty.$else$All fields in _$name$ will be reset to 0 before _buffer is interpreted.$endif$
 */
int $name$_read_delimited_from(void *_buffer, $if(empty)$$else$struct $name$ *_$name$, $endif$int offset);

>>

messageAttribute(modifier, typeName, typeClass, name, tag) ::= <<
$if(arrayModifiers.(modifier))$int _$name$_repeated_len;$endif$
$if(arrayTypes.(typeName))$$if(arrayModifiers.(modifier))$int _$name$_len[MAX_REPEATED_LEN];
$else$int _$name$_len;$endif$$endif$
$if(typeMap.(typeName))$$typeMap.(typeName)$$elseif(enumTypeMap.(typeClass))$enum $typeName$$else$struct $typeName$
$endif$ _$name$$if(arrayModifiers.(modifier))$[MAX_REPEATED_LEN]
$endif$$if(arraySTypes.(typeName))$[MAX_STRING_LEN]
$endif$$if(arrayBTypes.(typeName))$[MAX_BYTES_LEN]
$endif$;
>>

qualifiedID(ids) ::= <<$ids; separator="."$>>
